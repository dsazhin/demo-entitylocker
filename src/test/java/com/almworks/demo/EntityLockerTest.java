/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.almworks.demo;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

import org.hamcrest.CoreMatchers;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;

import lombok.SneakyThrows;

public class EntityLockerTest {
	@Mock
	Runnable job;

	Executor twoThreadExecutor = Executors.newFixedThreadPool(2);

	@Before
	public void before() {
		MockitoAnnotations.initMocks(this);
	}

	@Test
	public void execProtected_whenReentrant_isOk() {
		EntityLocker<Object> sut = new EntityLocker<>(5);
		final Object id1 = new Object();

		sut.execProtected(id1, () -> sut.execProtected(id1, job::run));

		Mockito.verify(job, Mockito.times(1)).run();
	}

	@Test
	public void execExclusively_whenReentrant_isOk() {
		EntityLocker<Object> sut = new EntityLocker<>(5);
		final Object id1 = new Object();

		sut.execExclusively(id1, () -> sut.execExclusively(id1, job::run));

		Mockito.verify(job, Mockito.times(1)).run();
	}

	@Test
	@SneakyThrows
	public void execProtected_whenConcurrentExecution_execAllTasks() {
		EntityLocker<Object> sut = new EntityLocker<>(1);
		final Object id1 = new Integer(1);
		final Object id2 = new Integer(2);
		final CyclicBarrier startBarrier = new CyclicBarrier(3);
		final CountDownLatch completionLatch = new CountDownLatch(2);
		final AtomicInteger exceptionsCounter = new AtomicInteger();
		twoThreadExecutor.execute(() -> {
			try {
				await(startBarrier);
				sut.execProtected(id1, () -> {
					try {
						sut.execProtected(id2, job::run);
					} catch (DeadlockDetectedException e) {
						exceptionsCounter.incrementAndGet();
					}
				});
			} finally {
				completionLatch.countDown();
			}
		});
		twoThreadExecutor.execute(() -> {
			try {
				await(startBarrier);
				sut.execProtected(id1, () -> {
					try {
						sut.execProtected(id2, job::run);
					} catch (DeadlockDetectedException e) {
						exceptionsCounter.incrementAndGet();
					}
				});
			} finally {
				completionLatch.countDown();
			}
		});
		// when
		startBarrier.await();
		completionLatch.await();
		// then
		Mockito.verify(job, Mockito.times(2)).run();
		Assert.assertThat(exceptionsCounter.get(), CoreMatchers.is(0));
	}

	@Test
	@SneakyThrows
	public void execProtected_whenDeadlock_detectIt() {
		EntityLocker<Object> sut = new EntityLocker<>(3);
		final Object id1 = new String("1");
		final Object id2 = new String("2");
		final CyclicBarrier startBarrier = new CyclicBarrier(3);
		final CountDownLatch completionLatch = new CountDownLatch(2);
		final AtomicInteger exceptionsCounter = new AtomicInteger();
		twoThreadExecutor.execute(() -> {
			try {
				sut.execProtected(id1, () -> {
					try {
						await(startBarrier);
						sut.execProtected(id2, job::run);
					} catch (DeadlockDetectedException e) {
						exceptionsCounter.incrementAndGet();
					}
				});
			} finally {
				completionLatch.countDown();
			}
		});
		twoThreadExecutor.execute(() -> {
			try {
				sut.execProtected(id2, () -> {
					try {
						await(startBarrier);
						sut.execProtected(id1, job::run);
					} catch (DeadlockDetectedException e) {
						exceptionsCounter.incrementAndGet();
					}
				});
			} finally {
				completionLatch.countDown();
			}
		});
		// when
		startBarrier.await();
		completionLatch.await();
		// then
		Mockito.verify(job, Mockito.times(1)).run();
		Assert.assertThat(exceptionsCounter.get(), CoreMatchers.is(1));
	}

	@Test
	@SneakyThrows
	public void execProtected_whenBothWorkersEscalatesToGlobal_aviodDeadlock() {
		EntityLocker<Object> sut = new EntityLocker<>(1);
		final Object id1 = new Integer(1);
		final Object id2 = new Integer(2);
		final Object id3 = new Integer(3);
		final Object id4 = new Integer(4);
		final Object id5 = new Integer(5);
		final Object id6 = new Integer(6);
		final CyclicBarrier startBarrier = new CyclicBarrier(3);
		final CountDownLatch completionLatch = new CountDownLatch(2);
		final AtomicInteger exceptionsCounter = new AtomicInteger();
		twoThreadExecutor.execute(() -> {
			try {
				sut.execProtected(id1, () -> {
					try {
						await(startBarrier);
						sut.execProtected(id2, ()->sut.execProtected(id3, job::run));
					} catch (DeadlockDetectedException e) {
						exceptionsCounter.incrementAndGet();
					}
				});
			} finally {
				completionLatch.countDown();
			}
		});
		twoThreadExecutor.execute(() -> {
			try {
				sut.execProtected(id4, () -> {
					try {
						await(startBarrier);
						sut.execProtected(id5, ()->sut.execProtected(id6, job::run));
					} catch (DeadlockDetectedException e) {
						exceptionsCounter.incrementAndGet();
					}
				});
			} finally {
				completionLatch.countDown();
			}
		});
		// when
		startBarrier.await();
		completionLatch.await();
		// then
		Mockito.verify(job, Mockito.times(2)).run();
		Assert.assertThat(exceptionsCounter.get(), CoreMatchers.is(0));
	}

	@SneakyThrows
	private void await(CyclicBarrier barrier) {
		barrier.await();
	}
}
